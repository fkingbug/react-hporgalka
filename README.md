**useMemo(callback , deps)**

useMemo в нашем примере производит вычесления , запоминает результат и кэширует (Мемоизация) , на каждую перерисовку компонента не делает перерасчеты , а берет их из кэша , Но если 1 из зависимостей изменилась , функция вновь пересчитывает и кэширует результат выполнения до тех пор пока 1 из зависимостей не изменится , если массив зависимосте пуст , то функция отработает 1 раз , запомнит результат и больше выполнятся не будет

- Первым параметром принимаем в себя колбек (функцию обратного вызова)
- CallBack должен возвращать результат вычеслений (отфильтрованный массиив и тд)
- Вторым Параметром принимает в себя массив зависимостей ( переменные поля объектов и тд)

```javascript
useMemo(()=> {
  return [...posts].sort(...)
}, [selectedSort , posts])
```

---

Теперь эта функция срабатывает когда меняется состояние [selectedSort, posts] , а не при каких либо изменениях (даже ввод данных в инпут)

```javascript
const sortedPosts = useMemo(() => {
  console.log('Мемо сработало')
  if (selectedSort) {
    return [...posts].sort((a, b) => a[selectedSort].localeCompare(b[selectedSort]))
  }
  return posts
}, [selectedSort, posts])
```

---
